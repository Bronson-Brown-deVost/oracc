#!/usr/bin/perl
use warnings; use strict;
use integer;
use utf8; use open 'utf8'; binmode(STDOUT, ':utf8');
use lib '@@ORACC@@/lib';
use ORACC::XML;
use ORACC::P2::Util2;
use Encode;
use Getopt::Long;

my $oracclib = '@@ORACC@@/lib';
my $oraccwww = '@@ORACC@@/www';

warn "p2-pager.plx invocation: @ARGV\n";

my %param = ();
GetOptions(
    'param=s' => \%param,
    );

my $bin = '@@ORACC@@/bin';
my $browse_ready = 'false';
my $ce_arg = '';
my $data_type = '';
my $mode = '';
my $p2launcher = 0;
my $list = '';
my $list_type = '';
my $nohttp = 0;
my $pg_wrapper_input = '';
my $project = '';
my $session = '';
my $state = '';
my $tmpdir = '';
my %values = ();
my $vartmp = '/var/tmp/oracc/pager';
my $view_type = '';
my $verbose = 1;
my $xdata = undef;

#if (defined $ENV{'SCRIPT_URL'}) {
#    $ENV{'QUERY_STRING'} = join('&',@ARGV)
#	unless $ENV{'QUERY_STRING'};
#}

$xdata = ORACC::P2::Util2::decode_args_or_cgi();
%values = ORACC::P2::Util2::set_values($xdata)
    if $xdata;

# values on command line override those in an xml file
foreach my $p (keys %param) {
    $values{$p} = $param{$p};
}

($session,$list,$tmpdir) 
    = ORACC::P2::Util2::setup_tmpdir($xdata,\%values);

warn "p2-pager: session=$session; list=$list; tmpdir=$tmpdir\n";

$nohttp = $values{'nohttp'} || 0;

fake_browse()
#    if ($values{'adhoc'} || $values{'browse'} || $values{'xis-lang'} || ($values{'glossary'} && $values{'glossary'} ne '#none'));
    if ($values{'adhoc'} || $values{'browse-list'} || $values{'xis-lang'});

$state = $values{'state'} unless $state;

if (!$state || $state eq 'startup') {
    fake_browse();
}

$state = 'browse' if !$state || $state eq 'startup';

unless ($xdata) {
    $xdata = fake_pager(\%values,$xdata);
    die "p2-pager.plx: failed to load or fake instance data\n"
	unless $xdata;
    %values = ORACC::P2::Util2::set_values($xdata);
}
ORACC::P2::Util2::save_instance($tmpdir,$xdata);

$project = $values{'project'};

# Perform any bump that is needed and clear the bump
# before returning. This is how P2 handles trapping
# the back/forward navigation and keeps the pager 
# properly synchronized.

bump() if $values{'bump'};

# determine the data type:
#
#   search-result , corpus-listing , glossary-listing

# if there's a glossary it's a glossary-listing; 
# if there is a list, it's a search-result; 
# else it's a corpus-listing.
if (($values{'glossary'} && $values{'glossary'} ne '#none')) {
    unless ($values{'search'} && $values{'search'} == 1) { # set to '1' when called after post-search
	setup_glossary_and_exit();
    } else {
	$data_type = 'glossary';
    }
} elsif ($values{'list'}) {
    $values{'glossary'} = '#none';
    $data_type = 'search';
    if (-z "$vartmp/$values{'session'}/$values{'list'}/results.lst") {
	setup_empty_results_and_exit();
    }
} else {
    $values{'glossary'} = '#none';
    $data_type = 'corpus';
}

# determine the natural list type:
# 
#   xtf , tra , cat , cbd

if ($data_type eq 'search') {
    $list_type = search_list_type();
} elsif ($data_type eq 'glossary') {
    $list_type = 'cbd';
} else {
    $list_type = 'cat';
}

# determine the requested list-view format
#
#   kwic , line , unit , para , text , summ , item

if ($list_type eq 'xtf' && !$values{'item'}) {
    if ($values{'cetype'}) {
	$view_type = $values{'cetype'};
    } else {
	$view_type = 'line';
    }
} elsif ($list_type eq 'tra') {
    if ($values{'item'}) {
	$view_type = 'item';
    } else {
	$view_type = 'para';
    }
} else {
    if ($values{'item'}) {
	$view_type = 'item';
    } else {
	$view_type = 'summ';
    }
}

# perform any necessary mapping of natural list IDs
# to list-view types (not all are possible)

if ($values{'cetype'}) {
    $ce_arg = $values{'cetype'};
    $ce_arg =~ s/^(.).*$/-$1/;
} elsif ($list_type eq 'xtf') {
    $ce_arg = '-l';
}

if ($verbose) {
    warn "data_type=$data_type; list_type=$list_type; view_type=$view_type; ce_arg=$ce_arg\n";
}

# In item mode, we just use the list we already have
# and grab the itemth non-heading line from it
if ($view_type eq 'item') {
    # first recalibrate item and page: values{item} is an integer
    # from 1 to values{items}; we need to split it into page and
    # offset
    my($newPage,$sedItem) = ();

    $newPage = ($values{'item'} / $values{'per-page'});
    ++$newPage unless !($values{'item'} % $values{'per-page'});
    $sedItem = ($values{'item'} % $values{'per-page'}) || $values{'per-page'};

    warn "newPage = $newPage; sedItem = $sedItem\n";

    $values{'page'} = $newPage;
    ORACC::P2::Util2::set_data($xdata,
			      page=>$newPage,
	);

    if ($list_type eq 'xtf') {
	xsystem('@@ORACC@@/bin/wm', "-p$values{'project'}", $ce_arg, "-i$tmpdir/results.lst", "-o$tmpdir/wm.out");
	$pg_wrapper_input = "$tmpdir/wm.out";
    } else {
	$pg_wrapper_input = "$tmpdir/results.lst";
    }
    run_pager();
#    run_content_maker();
    
    my $id = `grep -v '^#' $tmpdir/pgwrap.out | sed -n '${sedItem}p'`;
#    my $id = `grep -v '^#' $tmpdir/pgwrap.order | sed -n '${sedItem}p'`;
    chomp($id);
    warn "p2-pager: sedItem = $sedItem in $tmpdir/pgwrap.out yields id $id\n";
    if ($id) {
	if ($list_type eq 'cbd') {
	    setup_glossary_and_exit("/$values{'project'}/cbd/$values{'glossary'}/$id.html");
	} elsif ($list_type eq 'cat' && $values{'itemtype'} eq 'cat') {
	    $id =~ s/\..*$//;
	    my($eproject,$eid) = ($values{'project'},'');
	    if ($id =~ /^(.*?):(.*?)$/) {
		($eproject,$eid) = ($1,$2);
	    } else {
		$eid = $id;
	    }
	    ORACC::P2::Util2::set_data($xdata,
				      content=>"javascript:urlResults('/$eproject/$eid/cat')",
				      outline=> "javascript:oasOutline('$values{'project'}','$values{'session'}','$values{'list'}')");
	    
	    ORACC::P2::Util2::emit_instance($tmpdir,$xdata,'pager',
					   !$p2launcher,$p2launcher,
					   $project,$session
		);
	    exit 0;
	} else {
	    chomp($id);
	    my($eproject,$eid) = ($values{'project'},'');
	    if ($id =~ /^(.*?):(.*?)$/) {
		($eproject,$eid) = ($1,$2);
	    } else {
		$eid = $id;
	    }
	    my @idinfo = ();
	    $eid =~ s/_.*$//;
	    $eid =~ s/^.*?://;
	    $eid =~ s/\s.*$//;
	    my $line = $eid;
	    $eid =~ s/\..*$//;
	    my $base = $eid;
	    $base =~ s/^(....).*$/$1/;
	    if ($list_type =~ /^tra|xtf$/ && $view_type eq 'item') {
		@idinfo = ce_data_info($values{'item'});
	    } else {
		push(@idinfo, '-stringparam', 'line-id', $values{'itemline'})
		    if $values{'itemline'} && $values{'itemline'} ne 'none';
		push(@idinfo, '-stringparam', 'frag-id', $values{'itemctxt'})
		    if $values{'itemctxt'} && $values{'itemctxt'} ne 'none';
	    }
	    xsystem('xsltproc', 
		    '-stringparam', 'p2', 'yes',
		    '-stringparam', 'host', $project,
		    '-stringparam', 'project', $eproject,
		    '-stringparam', 'trans', $values{'translation'},
		    '-stringparam', 'transonly', $values{'transonly'},
		    @idinfo,
		    '-o', "$tmpdir/itemmain.html",
		    '@@ORACC@@/lib/scripts/p2-htmlview.xsl', 
		    "@@ORACC@@/bld/$eproject/$base/$eid/$eid.xmd");
	    sig_fixer($values{'project'});
	    xsystem('xsltproc', 
		    '-stringparam', 'project', $eproject,
		    '-o', "$tmpdir/itemside.html",
		    find_xmdoutline(),
		    "@@ORACC@@/bld/$eproject/$base/$eid/$eid.xmd");
	}

	ORACC::P2::Util2::set_data($xdata,
				  content=>"javascript:itemResults('$values{'project'}','$values{'session'}','$values{'list'}')",
				  outline=>"javascript:itemOutline('$values{'project'}','$values{'session'}','$values{'list'}')");
	
	ORACC::P2::Util2::emit_instance($tmpdir,$xdata,'pager',
				       !$p2launcher,$p2launcher,
				       $project,$session
	    );
	exit 0;
    }
    # if this gets called when there is no list, we just deliver
    # a list instead
}

if ($list_type eq 'xtf') {
    xsystem('@@ORACC@@/bin/wm', "-p$values{'project'}", $ce_arg, "-i$tmpdir/results.lst", "-o$tmpdir/wm.out");
    $pg_wrapper_input = "$tmpdir/wm.out";
} else {
    $pg_wrapper_input = "$tmpdir/results.lst";
}

run_pager();

# need to pass uzpage, zprev and znext back to instance from pgwrap.out

# Generate the outline dependent on what is in the
# content frame:
#
#  for search-result/corpus-listing this is the outline
#     -- this has been done already in s2-pg2wrapper.plx
#  for catalogue-items this is empty
#  for P-text-items this is the catalogue entry
#  for Q-text-items this is the catalogue entry+list of sources
#  for glossary searches this is still the standard TOC outline

# Generate the content for the content frame:
#
#   ce_xtf / ce_xmd / ce_tra / ce_cbd 
# or
#   html-maker for items

run_content_maker();

# Merge the pg info with the instance ...
merge_pg_info();

# ... and then launch a new p2 or return updated instance

ORACC::P2::Util2::emit_instance($tmpdir,$xdata,'pager',
			       !$p2launcher,$p2launcher,
			       $project,$session,$nohttp
    );

exit 0;

#######################################################

sub
bump {
    if ($values{'item'} && $values{'item'} >= 1) {
	# we are bumping an item up or down; if 
	# we bump down to 0 we'll exit item-mode
	if ($values{'bump'} eq 'forward') {
	    if ($values{'item'} < $values{'items'}) {
		$values{'item'} = $values{'item'} + 1;
		update_xdata('item');
	    }
	} else {
	    if ($values{'item'} == 1) {
		$values{'item'} = 0;
		$values{'state'} = $values{'newstate'};
	    } else {
		$values{'item'} = $values{'item'} - 1;
	    }
	    update_xdata('item');
	    update_xdata('state');
	}
    }
    $values{'bump'} = '';
    update_xdata('bump');
}

sub
ce_data_info {
    my $nth = shift;
    my @ret = ();
    my $xce = load_xml("$tmpdir/content.xml");
    if ($xce) {
	my @cedata = tags($xce,'http://oracc.org/ns/ce/1.0','data');
	my $cenode = $cedata[$nth-1];
	if ($cenode) {
	    my $line = $cenode->getAttribute('line-id');
	    my $ctxt = $cenode->getAttribute('context-id');
	    if ($line) {
		push(@ret, '-stringparam', 'line-id', $line);
		push(@ret, '-stringparam', 'frag-id', $ctxt)
		    if $ctxt;
	    }
	}
    }
    @ret;
}

sub
fake_browse {
    warn "p2-pager: fake_browse\n";
    my $project = $values{'project'};
    my $glossary = $values{'glossary'} || '#none';
    my $adhoc = $values{'adhoc'};
    my $browse = $values{'browse-list'};
    if ($adhoc) {
	die "p2-pager: project parameter is required\n"
	    unless $project;
	warn "p2-pager: (1) adhoc=$adhoc\n" if $verbose;
	xsystem('@@ORACC@@/bin/p2-browse.plx', 
		'-p', "project=$project", 
		'-p', "session=$session", 
		'-p', "list=$list",
		'-p', "adhoc=$adhoc", 
		'-p', "serialize=false");
	$p2launcher = 1;
	$state = 'default';
	set_mode();
    } elsif ($browse) {
	die "p2-pager: project parameter is required\n"
	    unless $project;
	warn "p2-pager: browse=$browse\n" if $verbose;
	xsystem('@@ORACC@@/bin/p2-browse.plx', 
		'-p', "project=$project", 
		'-p', "session=$session", 
		'-p', "list=$list",
		'-p', "browse-list=$browse", 
		'-p', "glossary=$glossary", 
		'-p', "serialize=false");
	$p2launcher = 1;
	$state = 'default';
	set_mode();
    } elsif ($glossary && $glossary ne '#none') {
	die "p2-pager: project parameter is required\n"
	    unless $project;
	warn "p2-pager: glossary=$glossary\n" if $verbose;
	xsystem('@@ORACC@@/bin/p2-browse.plx', 
		'-p', "project=$project", 
		'-p', "session=$session", 
		'-p', "glossary=$glossary", 
		'-p', "list=$list",
		'-p', "serialize=false");
	$p2launcher = 1;
	$state = 'default';
	$values{'mode'} = 'full';
	set_mode();
    } else {
	my $xis_lang = $values{'xis-lang'};
	if ($xis_lang) {
	    my $xis_id = $values{'xis-id'};
	    die "p2-pager: project parameter is required\n"
		unless $project;
	    warn "p2-pager: xis=$xis_lang $xis_id\n" if $verbose;
	    xsystem('@@ORACC@@/bin/p2-browse.plx', 
		    '-p', "project=$project", 
		    '-p', "session=$session", 
		    '-p', "list=$list",
		    '-p', "xis-lang=$xis_lang", 
		    '-p', "xis-id=$xis_id", 
		    '-p', "serialize=false");
	    $p2launcher = 1;
	    $state = 'default';
	    set_mode();
	}
    }
    $browse_ready = 'true',

}

#WATCHME: should mode-setting be independent of
#fake_pager?
sub
fake_pager {
    my %newdata = (
	session=>$session || '',
	list=>$list || '',
	project=>$values{'project'} || '',
	glossary=>$values{'glossary'} || '',
	'serialize'=>$values{'serialize'} || '',
	'state'=>$state,
	'mode'=>$mode,
	'use-unicode'=>$values{'use-unicode'} || '',
	'browse-ready'=>$browse_ready,
	'itemline'=>$values{'line-id'} || '',
	'itemctxt'=>$values{'frag-id'} || '',
	);
    my $adhocx = $values{'adhoc'} || '';
    if ($adhocx) {
	$newdata{'item'} = $newdata{'page'} = '';
	$newdata{'itemtype'} = '';
	$newdata{'item-init'} = 'false';
	$newdata{'items'} = ($values{'adhoc'} =~ tr/,/,/)+1;
	$newdata{'pages'} = ($newdata{'items'} / 25) + ($newdata{'items'}%25) ? 1 : 0;
	$newdata{'state'} = 'default'; # 'items';
    }
    $xdata = ORACC::P2::Util2::load_default_instance('pager');
    ORACC::P2::Util2::set_data($xdata,%newdata);
    my $itemx = $newdata{'item'} || '';
    warn "p2-pager: (2) adhoc=$adhocx; item=$itemx\n";
    $xdata;
}

sub
find_xmdoutline {
    my $eproject = $values{'project'};
    my $parent_project = $eproject;
    $parent_project =~ s#/.*$##;
    if (find_xmdoutline_sub("$oraccwww/$eproject/xmdoutline.xsl")) {
	"$oraccwww/$eproject/xmdoutline.xsl";
    } elsif ($parent_project ne $eproject && find_xmdoutline_sub("$oraccwww/$parent_project/xmdoutline.xsl")) {
	"$oraccwww/$parent_project/xmdoutline.xsl";
    } else {
	"$oracclib/scripts/p2-xmd.xsl";
    }
}

sub
find_xmdoutline_sub {
    my $ok = (-r $_[0] ? 'found' : 'not found');
    warn "trying xmdoutline $_[0] => $ok\n";
    $ok eq 'found';
}

sub
merge_pg_info {
    my %info = ();
    my @info = `cat $tmpdir/pg.xml`; # FIXME: this is a silly filename
    foreach my $i (@info) {
	next if $i =~ /^\#/;# || /^\S+?\.x/; # this second match is a hack to clear `sux.x1242342'
	my($tag,$val) = ($i =~ /^(.*?)\s+(.*?)$/);
	$info{$tag} = $val;
    }
    if ($values{'glossary'} && $values{'glossary'} ne '#none') {
	$info{'outline'}
	= "javascript:cbdOutline('/$values{'project'}/cbd/$values{'glossary'}/p2-toc.html')";
    } else {
	$info{'outline'} 
	= "javascript:oasOutline('$values{'project'}','$values{'session'}','$values{'list'}')";
    }
    $info{'content'} 
    = "javascript:oasResults('$values{'project'}','$values{'session'}','$values{'list'}')";

    ORACC::P2::Util2::set_data($xdata,%info);    
}

sub
run_content_maker {
    my $vminus = $values{'page'} || 0;
    $vminus -= 1 if $vminus;
    my $item_offset = ($vminus) * $values{'per-page'};
    my @offset_arg = ('-o', $item_offset);
    my @offset_param = ('-stringparam', 'item-offset', $item_offset);
    if ($list_type eq 'xtf') { ## sigfixer may need adding to end of pipe here some day
	xsystem("cat $tmpdir/pgwrap.out | @@ORACC@@/bin/ce_xtf $ce_arg -p $values{'project'} | @@ORACC@@/bin/s2-ce_trim.plx >$tmpdir/content.xml");
	xsystem('xsltproc', '-stringparam', 'project', $values{'project'}, @offset_param, '-o', "$tmpdir/results.html", '@@ORACC@@/lib/scripts/s2-ce-xtf-HTML.xsl', "$tmpdir/content.xml");
    } elsif ($list_type eq 'cat' || $list_type eq 'tra') {
	my $link_fields = `@@ORACC@@/bin/oraccopt $values{'project'} catalog-link-fields`;
	my $lfopt = ($link_fields ? "-a$link_fields" : '');
	warn "lfopt=$lfopt\n";
	xsystem("cat $tmpdir/pgwrap.out | @@ORACC@@/bin/ce2 $lfopt -S$values{'state'} @offset_arg -i$list_type -p $values{'project'} >$tmpdir/content.xml");
	xsystem('xsltproc', '-stringparam', 'project', $values{'project'}, @offset_param, '-o', "$tmpdir/results.html", '@@ORACC@@/lib/scripts/s2-ce-xtf-HTML.xsl', "$tmpdir/content.xml");
    } elsif ($list_type eq 'cbd') {
	xsystem("cat $tmpdir/pgwrap.out | @@ORACC@@/bin/ce2 -S$values{'state'} -icbd/$values{'glossary'} -p $values{'project'} >$tmpdir/content.xml");
	xsystem('xsltproc', '-stringparam', 'project', $values{'project'}, @offset_param, '-o', "$tmpdir/results.html", '@@ORACC@@/lib/scripts/s2-ce-xtf-HTML.xsl', "$tmpdir/content.xml");    
    }
}

# Now we have the list that the pager has to work with,
# run the pager to determine what is in the content
# frame:
sub
run_pager {
    my $pgargs = setup_pgargs();
    xsystem('@@ORACC@@/bin/s2-pg2wrapper.plx', $ce_arg, 
	    '-s', $values{'state'}, 
	    '-P', $values{'project'}, 
	    '-p', $pgargs, 
	    '-i', $pg_wrapper_input, 
	    '-o', "$tmpdir/pgwrap.out");
}

sub
search_list_type {
    if (-r "$tmpdir/results.xml") {
	my $ret = `cat $tmpdir/results.xml`;
	my %types = (
	    lem=>'xtf',
	    l24=>'xtf',
	    txt=>'xtf',
	    );
	my($resindex) = ($ret =~ /<index>(.*?)</);
	my $t = $types{$resindex} || $resindex;
	$t =~ s#/.*$##;
	$t;
    } else {
	'cat';
    }
}

sub
setup_empty_results_and_exit {
    open(O,">$vartmp/$values{'session'}/$values{'list'}/outline.html");
    open(R,">$vartmp/$values{'session'}/$values{'list'}/results.html");
    print O '<html xmlns="http://www.w3.org/1999/xhtml"><body/></html>';
    print R '<html xmlns="http://www.w3.org/1999/xhtml"><body><p>No results.</p></body></html>';
    close(O);
    close(R);

    ORACC::P2::Util2::set_data($xdata,
			      content=>"javascript:oasResults('$values{'project'}','$values{'session'}','$values{'list'}')",
			      outline=>"javascript:oasOutline('$values{'project'}','$values{'session'}','$values{'list'}')");

    ORACC::P2::Util2::emit_instance($tmpdir,$xdata,'pager',
				   !$p2launcher,$p2launcher,
				   $project,$session,$nohttp
	);
    exit 0;
}

sub
set_mode {
    $mode = $values{'mode'} || 'minimal';
}

sub
setup_glossary_and_exit {
    my $res = shift || '/p2/p2-cbd-init.html';
    my $toc = "/$values{'project'}/cbd/$values{'glossary'}/p2-toc.html";

    ORACC::P2::Util2::set_data($xdata,
			      content=>"javascript:cbdResults('$res')",
			      outline=>"javascript:cbdOutline('$toc')");

    ORACC::P2::Util2::emit_instance($tmpdir,$xdata,'pager',
				   !$p2launcher,$p2launcher,
				   $project,$session,$nohttp
	);
    exit 0;
}

sub
setup_pgargs {
    $values{'page'} = 1 unless $values{'page'};
    my $tmpstate = ($values{'state'} =~ /^default|special$/ ? $values{'state'} : $values{'pushed-state'});
    $tmpstate = 'default' unless $tmpstate;
    my @args = ('2', '-m', "-p$values{'project'}", "-P$values{'per-page'}", 
		"-n$values{'page'}", "-S$tmpstate");

    push @args, '-q', if $list_type eq 'cbd';
    if ($tmpstate && $values{"$tmpstate-sort"}) {
	my $tmp = $values{"$tmpstate-sort"};
	$tmp =~ tr/_/^/; # escape field names like ch_no
	push(@args, "-s$tmp") if $tmp;
    }
    push @args, "-z$values{'zoom'}" if $values{'zoom'};
    join('_', @args);
}

# sig_fixer($project)
sub
sig_fixer {
    my $p = shift;
    local($/) = undef;
    open(T, "$tmpdir/itemmain.html");
    my $text = <T>;
    close(T);
#    my ($l) = ($text =~ /\%(.*?):/);
#    if ($l) {
#	unless (-d "@@ORACC@@/www/$p/cbd/$l") {
#	    $l =~ s/-.*$//;
#	    unless (-d "@@ORACC@@/www/$p/cbd/$l") {
#		$l = '';
#	    }
#	}
#    } else {
#	$l = '';
#    }
    my $l = '';
    my $reps = ($text =~ s/(pop1sig\()/pop1sig('$p','$l',/go);
    open(T,">$tmpdir/itemmain.html");
    print T $text;
    close(T);
}

sub
update_xdata {
    ORACC::P2::Util2::set_data($xdata, $_[0]=>$values{$_[0]});
}

sub
xsystem {
    warn "system @_\n"
	if $verbose;
    system @_;
}

1;
